<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>관리자 — 학생 수강 내역 & 시간표</title>
  <style>
    :root{--border:#dcdcdc;--ok:#138000;--bad:#d10000}
    body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;max-width:1100px;margin:16px auto;padding:16px}
    h1{margin:0 0 12px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    input[type="text"], select{padding:8px;border:1px solid var(--border);border-radius:6px;font-size:14px}
    button{padding:8px 12px;border-radius:6px;border:0;background:#0275d8;color:#fff;cursor:pointer}
    button.ghost{background:#f5f5f5;color:#000;border:1px solid #ddd}
    .two-col{display:grid;grid-template-columns:320px 1fr;gap:12px}
    .panel{border:1px solid var(--border);padding:12px;border-radius:8px;background:#fff}
    table{width:100%;border-collapse:collapse}
    th,td{border:1px solid var(--border);padding:8px;text-align:left;font-size:13px}
    th{background:#f7f7f7}
    .student-row{cursor:pointer}
    .student-row:hover{background:#f0f8ff}
    .small{font-size:13px;color:#666}
    .table-wrapper{overflow:auto;border:1px solid #eee;padding:6px;background:#fff}
    td.cell-read{background:#ccffcc !important;color:#000;font-weight:600}
    td.cell-movie{background:#ffd9b3 !important;color:#000;font-weight:600}
    td.cell-lounge{background:#cce5ff !important;color:#000;font-weight:600}
    td.cell-bible{background:#fff9b3 !important;color:#000;font-weight:600}
    .meta{font-size:13px;color:#444;margin-bottom:8px}
    .muted{color:#666;font-size:13px}
    .actions{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
    @media (max-width:880px){
      .two-col{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <h1>관리자 모드 — 학생 수강 내역 & 시간표</h1>
  <p class="muted">Supabase의 students, registrations, course_capacity 테이블을 사용합니다. 익명 키가 노출된 환경에서는 외부 접근 위험이 있으니 로컬/보호된 환경에서만 사용하세요.</p>

  <div class="controls">
    <input id="filterClass" type="text" placeholder="반 필터 (예: 2-3반)">
    <input id="filterName" type="text" placeholder="이름 필터 (부분검색 가능)">
    <button id="btnRefresh">목록 갱신</button>
    <button id="btnShowAll" class="ghost">모든 학생 시간표 보기</button>
    <button id="btnExportCSV" class="ghost">현재 선택 / 모두 CSV로 내보내기</button>
  </div>

  <div class="two-col">
    <div class="panel">
      <h3 style="margin-top:0">학생 목록</h3>
      <div class="meta small">학생을 클릭하면 우측에서 해당 학생의 시간표를 확인합니다.</div>
      <div id="studentsWrap" style="max-height:640px;overflow:auto">
        <table id="studentsTable">
          <thead><tr><th style="width:70px">ID</th><th>반</th><th>이름</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="panel">
      <div id="viewer">
        <h3 id="viewerTitle" style="margin-top:0">선택된 학생 없음</h3>
        <div id="viewerMeta" class="meta"></div>

        <div id="timetableArea" class="table-wrapper" aria-live="polite"></div>

        <div id="registrationsArea" style="margin-top:12px"></div>

        <div class="actions">
          <button id="btnRefreshStudent" class="ghost">이 학생의 신청 다시 불러오기</button>
          <button id="btnDeleteRegs" class="ghost" title="테스트용: 이 학생의 registrations 삭제">이 학생 신청 삭제</button>
        </div>
      </div>
    </div>
  </div>

  <div style="margin-top:12px" class="muted">참고: 시간표는 "makeTable" 페이지에서 사용한 동일한 교시/날짜 레이아웃으로 표시됩니다. registrations.course_capacity_id 값 포맷에 따라 파싱합니다.</div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // Supabase 설정 (기존과 동일)
    const SUPABASE_URL = 'https://metdfyhhcvvjmkkwyvcf.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1ldGRmeWhoY3Z2am1ra3d5dmNmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ5OTQzOTUsImV4cCI6MjA4MDU3MDM5NX0.vcC6tjeYU9CQlC92jJOKgcf3cR0t36g5J19pk2uQrDs';
    const { createClient } = window.supabase;
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // 시간표 구성 상수 (makeTable과 동일한 날짜/교시 구성)
    const DAYS = ["1/26(월)","1/27(화)","1/28(수)","1/29(목)","1/30(금)","2/2(월)","2/3(화)","2/5(목)"];
    const PERIODS = [1,2,3,4,5];

    // 유틸
    function escapeHtml(s){ if (s===null||s===undefined) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

    // students 목록 로드 (필터 지원: class exact, name ILIKE)
    async function loadStudents(){
      try {
        const cls = document.getElementById('filterClass').value.trim();
        const name = document.getElementById('filterName').value.trim();
        let q = supabase.from('students').select('student_id,class,name').order('student_id', { ascending:true });
        if (cls) q = q.eq('class', cls);
        if (name) q = q.ilike('name', `%${name}%`);
        const { data, error } = await q;
        if (error) throw error;
        const tbody = document.querySelector('#studentsTable tbody');
        tbody.innerHTML = '';
        if (!data || data.length === 0) {
          tbody.innerHTML = '<tr><td colspan="3" class="muted">데이터 없음</td></tr>';
          return;
        }
        for (const s of data) {
          const tr = document.createElement('tr');
          tr.className = 'student-row';
          tr.dataset.studentId = s.student_id;
          tr.innerHTML = `<td>${escapeHtml(s.student_id)}</td><td>${escapeHtml(s.class)}</td><td>${escapeHtml(s.name)}</td>`;
          tr.addEventListener('click', ()=>selectStudent(s.student_id, s.class, s.name));
          tbody.appendChild(tr);
        }
      } catch (err) {
        console.error(err);
        alert('학생 목록 조회 실패: ' + (err.message || err));
      }
    }

    // 선택된 학생의 registrations 불러오기
    async function fetchRegistrationsForStudent(studentId){
      const { data, error } = await supabase.from('registrations').select('registration_id,course_capacity_id').eq('student_id', studentId);
      if (error) throw error;
      return data || [];
    }

    // course_capacity 메타(있으면) 미리 불러오기 (id -> {id, max_capacity, ...})
    let courseCapacityIndex = null;
    async function loadCourseCapacities(){
      try {
        const { data, error } = await supabase.from('course_capacity').select('*');
        if (error) throw error;
        courseCapacityIndex = {};
        if (data) for (const r of data) courseCapacityIndex[r.id] = r;
      } catch (err) {
        // 테이블이 없거나 권한 문제일 수 있음 — 무시는 가능
        console.warn('course_capacity 로드 실패 (관리자 UI는 동작 가능):', err.message || err);
        courseCapacityIndex = {};
      }
    }

    // registrations 배열에서 시간표 데이터로 변환
    // courseId 포맷에 맞춰 파싱: "select_0126_선택1", "책 읽기_1/27(화)_1교시_승현반",
    // "movie_1/27(화)_1-2교시", "마네_1/27(화)_3교시", "bible_1/27(화)_1교시"
    function buildTableFromCourseIds(courseIds){
      // initialize empty tableData
      const tableData={};
      DAYS.forEach(d=>{ tableData[d] = {}; PERIODS.forEach(p=> tableData[d][p] = ''); });

      for (const cid of courseIds) {
        if (!cid || typeof cid !== 'string') continue;
        // 선택수업: 시작 with select_
        if (cid.startsWith('select_')) {
          // format: select_<day>_<subject>
          const parts = cid.split('_');
          // join rest as subject in case subject contains underscores
          const dayPart = parts[1] || '';
          const subject = parts.slice(2).join('_') || '선택수업';
          // map dayPart like 0126 -> "1/26(월)" using DAYS
          // simple mapping helper:
          const map = { '0126':"1/26(월)", '0127':"1/27(화)", '0128':"1/28(수)", '0129':"1/29(목)", '0202':"2/2(월)" };
          const day = map[dayPart] || dayPart;
          // 선택수업은 5교시(또는 4교시인 2/2)
          if (tableData[day]) {
            const period = (day === "2/2(월)") ? 4 : 5;
            tableData[day][period] = `선택수업(${subject})`;
          }
          continue;
        }

        if (cid.startsWith('책 읽기_') || cid.startsWith('책읽기_')) {
          // possible formats:
          // "책 읽기_1/27(화)_1교시_승현반"
          // "책 읽기_1/27(화)_1교시_승현반" (generateCapacityIds used: `책 읽기_${day}_${period}교시_${sel.value}`)
          // handle both with split by '_'
          const parts = cid.split('_');
          // attempt to find a day like "1/27(화)" in parts
          let day='', periodNum=null, subj='';
          for (let i=1;i<parts.length;i++){
            if (DAYS.includes(parts[i])) { day = parts[i]; periodNum = Number((parts[i+1]||'').replace('교시','')) || null; subj = parts.slice(i+2).join('_'); break; }
          }
          // fallback: try regex
          if (!day) {
            const m = cid.match(/책\s*읽기_([^_]+)_(\d+)교시_(.+)/);
            if (m) { day = m[1]; periodNum = Number(m[2]); subj = m[3]; }
          }
          if (day && periodNum && tableData[day]) {
            tableData[day][periodNum] = `책읽기(${subj||'독서'})`;
          }
          continue;
        }

        if (cid.startsWith('movie_')) {
          // e.g. movie_1/27(화)_1-2교시
          const m = cid.match(/^movie_([^_]+)_(\d-\d교시|\d-\d교시|1-2교시|3-4교시|1-2|3-4|1-2교시)$/);
          // more permissive:
          const parts = cid.split('_');
          const day = parts[1] || '';
          const blk = parts[2] || '';
          let start = null;
          if (/1-2/.test(blk)) start = 1;
          else if (/3-4/.test(blk)) start = 3;
          else {
            const m2 = blk.match(/(\d)[^\d]*(\d)/);
            if (m2) start = Number(m2[1]);
          }
          if (tableData[day] && start) {
            tableData[day][start] = '영화';
            if (tableData[day][start+1] !== undefined) tableData[day][start+1] = '영화';
          }
          continue;
        }

        if (cid.startsWith('마네_') || cid.startsWith('마네')) {
          // 마네_1/27(화)_3교시
          const parts = cid.split('_');
          const day = parts[1] || '';
          const pRaw = parts[2] || parts.slice(-1)[0] || '';
          const m = pRaw.match(/(\d+)/);
          const p = m ? Number(m[1]) : null;
          if (day && p && tableData[day]) tableData[day][p] = '마네';
          continue;
        }

        if (cid.startsWith('bible_') || cid.startsWith('bible')) {
          // bible_1/27(화)_1교시
          const parts = cid.split('_');
          const day = parts[1] || '';
          const pRaw = parts[2] || parts.slice(-1)[0] || '';
          const m = pRaw.match(/(\d+)/);
          const p = m ? Number(m[1]) : null;
          if (day && p && tableData[day]) tableData[day][p] = '성경동화';
          continue;
        }

        // Fallback: if courseCapacityIndex contains a matching id, attempt to format using its meta
        if (courseCapacityIndex && courseCapacityIndex[cid]) {
          const meta = courseCapacityIndex[cid];
          // try to infer from id or meta.name
          const id = cid;
          if (id.includes('select_')) {
            const parts = id.split('_'); const dayPart = parts[1]; const subj = parts.slice(2).join('_');
            const map = { '0126':"1/26(월)", '0127':"1/27(화)", '0128':"1/28(수)", '0129':"1/29(목)", '0202':"2/2(월)" };
            const day = map[dayPart] || dayPart;
            const period = (day === "2/2(월)") ? 4 : 5;
            if (tableData[day]) tableData[day][period] = `선택수업(${subj})`;
            continue;
          }
        }

        // if unrecognized, put raw id into a spare slot: 1/26 5교시 scavenger
        // try to attach to first empty slot
        outer:
        for (const d of DAYS) {
          for (const p of PERIODS) {
            if (!tableData[d][p]) { tableData[d][p] = cid; break outer; }
          }
        }
      } // end for cid

      return tableData;
    }

    // 화면에 시간표 그리기 (makeTable과 비슷한 레이아웃)
    function renderTimetableHtml(cls, name, tableData){
      let html = `<h4 style="margin:6px 0">${escapeHtml(cls||'')} ${escapeHtml(name||'')} 시간표</h4>`;
      html += `<div class="table-wrapper"><table><tr><th>교시/날짜</th>`;
      for (const d of DAYS) html += `<th>${escapeHtml(d)}</th>`;
      html += `</tr>`;
      for (const p of PERIODS) {
        html += `<tr><th>${p}교시</th>`;
        for (const d of DAYS) {
          const rawVal = tableData[d] ? (tableData[d][p] || '') : '';
          const val = (typeof rawVal === 'string') ? rawVal : String(rawVal);
          let cName = '';
          if (val.trim().startsWith('책읽기')) cName='cell-read';
          else if (val === '영화') cName='cell-movie';
          else if (val === '마네') cName='cell-lounge';
          else if (val === '성경동화') cName='cell-bible';
          html += `<td class="${cName}">${escapeHtml(val)}</td>`;
        }
        html += `</tr>`;
      }
      html += `</table></div>`;
      return html;
    }

    // 선택 학생 처리 흐름
    let currentStudent = null;
    async function selectStudent(studentId, cls, name){
      currentStudent = { studentId, class: cls, name };
      document.getElementById('viewerTitle').textContent = `${cls} ${name}`;
      document.getElementById('viewerMeta').textContent = `student_id: ${studentId}`;
      document.getElementById('timetableArea').innerHTML = '<div class="muted">불러오는 중...</div>';
      document.getElementById('registrationsArea').innerHTML = '';
      try {
        const regs = await fetchRegistrationsForStudent(studentId);
        const courseIds = regs.map(r => r.course_capacity_id);
        // build tableData
        const tableData = buildTableFromCourseIds(courseIds);
        document.getElementById('timetableArea').innerHTML = renderTimetableHtml(cls, name, tableData);

        // registrations raw list
        let html = '<h4 style="margin:10px 0 6px">등록된 Course IDs</h4>';
        if (!courseIds || courseIds.length === 0) html += '<div class="muted">신청된 수업이 없습니다.</div>';
        else {
          html += '<table><thead><tr><th>registration_id</th><th>course_capacity_id</th></tr></thead><tbody>';
          for (const r of regs) html += `<tr><td>${escapeHtml(r.registration_id)}</td><td>${escapeHtml(r.course_capacity_id)}</td></tr>`;
          html += '</tbody></table>';
        }
        document.getElementById('registrationsArea').innerHTML = html;
      } catch (err) {
        console.error(err);
        document.getElementById('timetableArea').innerHTML = `<div class="muted">불러오기 실패: ${escapeHtml(err.message||err)}</div>`;
      }
    }

    // 모든 학생에 대해 시간표 한 번에 렌더링 (화면에 길게 보여줌)
    async function showAllTimetables(){
      document.getElementById('viewerTitle').textContent = '모든 학생 시간표 (로딩 중...)';
      document.getElementById('viewerMeta').textContent = '';
      document.getElementById('timetableArea').innerHTML = '<div class="muted">로딩 중...</div>';
      try {
        // load students (with optional filters)
        const cls = document.getElementById('filterClass').value.trim();
        const name = document.getElementById('filterName').value.trim();
        let q = supabase.from('students').select('student_id,class,name').order('student_id', { ascending:true });
        if (cls) q = q.eq('class', cls);
        if (name) q = q.ilike('name', `%${name}%`);
        const { data: students, error: sErr } = await q;
        if (sErr) throw sErr;
        if (!students || students.length === 0) {
          document.getElementById('timetableArea').innerHTML = '<div class="muted">학생이 없습니다.</div>';
          return;
        }
        // fetch registrations for these students in bulk
        const ids = students.map(s=>s.student_id);
        const { data: regs, error: rErr } = await supabase.from('registrations').select('registration_id,student_id,course_capacity_id').in('student_id', ids);
        if (rErr) throw rErr;
        // group regs by student
        const regsByStudent = {};
        for (const r of regs || []) {
          if (!regsByStudent[r.student_id]) regsByStudent[r.student_id] = [];
          regsByStudent[r.student_id].push(r.course_capacity_id);
        }
        // build HTML for all students
        let html = '';
        for (const s of students) {
          const courseIds = regsByStudent[s.student_id] || [];
          const tableData = buildTableFromCourseIds(courseIds);
          html += renderTimetableHtml(s.class, s.name, tableData);
          html += `<div class="muted" style="margin-bottom:18px">student_id: ${s.student_id} — 등록 수: ${courseIds.length}</div>`;
        }
        document.getElementById('timetableArea').innerHTML = html;
        document.getElementById('viewerTitle').textContent = `모든 학생 시간표 (${students.length}명)`;
      } catch (err) {
        console.error(err);
        document.getElementById('timetableArea').innerHTML = `<div class="muted">불러오기 실패: ${escapeHtml(err.message||err)}</div>`;
      }
    }

    // CSV export: 현재 선택 학생 or all students shown in timetableArea
    async function exportCsv(){
      // if a student is selected, export that one; otherwise export all students matching filters
      if (currentStudent) {
        // fetch regs and create CSV for that student
        const regs = await fetchRegistrationsForStudent(currentStudent.studentId);
        const rows = [['student_id','class','name','registration_id','course_capacity_id']];
        for (const r of regs) rows.push([currentStudent.studentId, currentStudent.class, currentStudent.name, r.registration_id, r.course_capacity_id]);
        downloadCsv(rows, `${currentStudent.class}_${currentStudent.name}_registrations.csv`);
        return;
      }
      // else export all students matching filter
      const cls = document.getElementById('filterClass').value.trim();
      const name = document.getElementById('filterName').value.trim();
      let q = supabase.from('students').select('student_id,class,name').order('student_id', { ascending:true });
      if (cls) q = q.eq('class', cls);
      if (name) q = q.ilike('name', `%${name}%`);
      const { data: students, error: sErr } = await q;
      if (sErr) { alert('학생 조회 실패: ' + sErr.message); return; }
      const ids = students.map(s=>s.student_id);
      const { data: regs, error: rErr } = await supabase.from('registrations').select('registration_id,student_id,course_capacity_id').in('student_id', ids);
      if (rErr) { alert('등록 조회 실패: ' + rErr.message); return; }
      // map student info
      const byId = {}; for (const s of students) byId[s.student_id] = s;
      const rows = [['student_id','class','name','registration_id','course_capacity_id']];
      for (const r of regs) {
        const s = byId[r.student_id] || { class:'', name:'' };
        rows.push([r.student_id, s.class, s.name, r.registration_id, r.course_capacity_id]);
      }
      downloadCsv(rows, `all_registrations_${new Date().toISOString().slice(0,10)}.csv`);
    }

    function downloadCsv(rows, filename){
      const csv = rows.map(r => r.map(c => `"${String(c||'').replace(/"/g,'""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename || 'export.csv';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // 삭제 버튼 (주의: destructive)
    async function deleteCurrentStudentRegistrations(){
      if (!currentStudent) { alert('먼저 학생을 선택하세요.'); return; }
      if (!confirm(`student_id ${currentStudent.studentId}의 registrations를 모두 삭제합니다. 계속할까요?`)) return;
      try {
        const { error } = await supabase.from('registrations').delete().eq('student_id', currentStudent.studentId);
        if (error) throw error;
        alert('삭제 완료');
        selectStudent(currentStudent.studentId, currentStudent.class, currentStudent.name);
      } catch (err) {
        console.error(err);
        alert('삭제 실패: ' + (err.message || err));
      }
    }

    // init
    (async function init(){
      // load course_capacity index if exists (optional)
      await loadCourseCapacities();
      await loadStudents();

      // wire buttons
      document.getElementById('btnRefresh').addEventListener('click', loadStudents);
      document.getElementById('btnShowAll').addEventListener('click', showAllTimetables);
      document.getElementById('btnExportCSV').addEventListener('click', exportCsv);
      document.getElementById('btnRefreshStudent').addEventListener('click', ()=>{
        if (!currentStudent) return alert('학생을 선택하세요.');
        selectStudent(currentStudent.studentId, currentStudent.class, currentStudent.name);
      });
      document.getElementById('btnDeleteRegs').addEventListener('click', deleteCurrentStudentRegistrations);

      // keyboard: Enter on filters triggers refresh
      document.getElementById('filterName').addEventListener('keydown', (e)=>{ if (e.key === 'Enter') loadStudents(); });
      document.getElementById('filterClass').addEventListener('keydown', (e)=>{ if (e.key === 'Enter') loadStudents(); });
    })();
  </script>
</body>
</html>